function [SEU_Probs,Rad_Accum]=StormSeedGenerator_Final(sc_shielding,numSeeds,Component_Type,full_period,SatName);
%% Requirements:
%In order for this to generate the storms, their PFUs, and SEUs correctly
%there needs to be:
%1. A structure array named "storms" with the correct naming conventions (generated by 'StormIsolator_Final.m' and propagated through 'GeomagneticShielding_Final.m')
%2. A variable named "depths" of all the shielding depths included in the storms (generated by the 'DoseCalculations_Final.m' file
%3. The background radiation named 'BackgroundSolarCycleDoses.mat' (generated by 'BackgroundRadiation_Final.m' with your AE9AP9 output files)
%4. A table of SEU rates per orbit for each device, shielding level (for which it will interpolate for all shielding levels), and storm intensities (1-5)
%% Overview:
%In order to save computation time on the Monte Carlos for different
%designs and policy implementations, all storms and their effects on the
%spacecraft can be pre-generated and seeded. That way each solar cycle does
%not have to be generated during the Monte Carlo, just pulled from this
%matrix.

final_radiation=[];
%for sc_shielding=[10 20 30 80 100];%Set the amount of spacecraft shielding (in mils)
%% User Inputs
% full_period=11; %Set the number of years you want to simulate for
TotalSeeds=numSeeds; %Set the number of Monte Carlo simulations you want to run
% sc_shielding=80;%Set the amount of spacecraft shielding (in mils)
% Component_Type=3; %1 = Space-Grade, 2 = Space-Tolerant, 3 = COTS - only used for SEUs

%% Pre-Allocation
S4_Times_All=[]; %We set up flags for when major events happen so that we can 1. validate that a feasible number were generated
S5_Times_All=[]; %and we also want to focus on specifically on runs where these occurred in order to see if the system is resilient to extreme events
Num_S5s=0;
S5_Cycles=0;
unshielded_radiation_all=zeros(TotalSeeds,length(full_period));
cum_radiation_all=zeros(TotalSeeds,length(full_period));
total_storms=zeros(1,TotalSeeds);
monthly_storms=zeros(TotalSeeds,length(full_period));
load(append('D:\Storm_Doses_',SatName,'.mat'))%Loads shielding depths if not left over from BackgroundRadiation_Final
load('D:\depths.mat')%Loads shielding depths if not left over from BackgroundRadiation_Final
load('D:\Materials\SPE_Intensity_Dist.mat'); %Load the probability distribution for SPE Intensity
load(append('D:\BackgroundSolarCycleDoses_',SatName,'.mat'));%Load background solar cycle doses
BackgroundSolarCycleDoses(1,:)=[]; %to fix an bug
load(append('D:\Materials\SEURatesData_',SatName,'.mat'));%Load the xilinx SEU data that stands for our space-grade, space-tolerant, and COTS representatives. If you want to input your own, format it like this. Only the rates per orbit are needed.  
%% Initialize SPE Frequency Variables
tic
theta_null=19.52;
K=55.89;
p=4.073;
q=4.82;
t=[1:4000]/4000;

%% Initialize SPE Dose Fit to PFU Levels based on Shielding
fit_params=[];          %at the end, we want a list of fit parameters for each shielding level so we can interpolate for a desired level
for ii=1:length(depths) %so for each shielding level
        radAccum=[];    %we're going to find how many krads were accumulated...    
        for i=1:length(storm)  %for each storm
            radAccum=horzcat(radAccum,storm(i).stormKrad(1,ii)); %so that we have an array of all the krad for each storm at the current shielding level
        end
        Const = polyfit(log10([storm(:).NOAA_PFU]),log10(radAccum),1);%fit the log-log space curve, so now we relate PFU to amount of radiation expected at that shielding level
        m = Const(1); fit_params(ii,1)=m;%save our fit parameters so we can interpolate with them later
        k = Const(2); fit_params(ii,2)=k;
        %extrapolated_doses = 10.^(m.*log10([1:150000])+(k)); %not neccessary but this is how we would check if the extrapolation was a good fit
end
fit_params=horzcat(fit_params,depths'); %now we have fit parameters that relate PFU to expected krads received at each shielding level based on the krad received from all storms at that shielding level

sc_shielding_m_dose=interp1(fit_params(:,3),fit_params(:,1),sc_shielding); %and we can use these to interpolate fit parameters for a user-specified shielding level
sc_shielding_k_dose=interp1(fit_params(:,3),fit_params(:,2),sc_shielding); %so when we stochastically generate a storm's PFU, we can translate that to the expected dose the spacecraft would receive with it's given shielding level (and orbit)

%% Initialize SEU Fit to PFU Levels based on Shielding
COTS_IDX_Config=contains(string(SEURatesData.DeviceName),'Kintex-7 Config');
SpaceTolerantIDX_Config=contains(string(SEURatesData.DeviceName),'XCKU040 ConfigMem');
SpaceGradeIDX_Config=contains(string(SEURatesData.DeviceName),'XQRKU060 Config');

COTS_IDX_Block=contains(string(SEURatesData.DeviceName),'Kintex-7 blockRAM');
SpaceTolerantIDX_Block=contains(string(SEURatesData.DeviceName),'XCKU040 BlockRAM');
SpaceGradeIDX_Block=contains(string(SEURatesData.DeviceName),'XQRKU060 blockRAM');

if Component_Type==1 %1 = Space-Grade, 2 = Space-Tolerant, 3 = COTS - only used for SEUs
    idx_Config=SpaceGradeIDX_Config;
    idx_Block=SpaceGradeIDX_Block;
elseif Component_Type==2
    idx_Config=SpaceTolerantIDX_Config;
    idx_Block=SpaceTolerantIDX_Block;
elseif Component_Type==3
    idx_Config=COTS_IDX_Config;
    idx_Block=COTS_IDX_Block;
else
    throw("Error: Not a valid component index");
end

fit_params=[];%just like dose: at the end, we want a list of fit parameters for each shielding level so we can interpolate for a desired level. However, now we also have a spacegrade component type or not. Whereas space-grade doesn't change how much dose something receives (just the threshold for failure), it does change the SEU rate.
for ii=[unique(SEURatesData.Shielding)'] %so for each shielding level
        %Block_Upsets=SEURatesData.UpsetRateDeviceOrbit(SEURatesData.Shielding(idx_Block)==ii);
        Config_Upsets=SEURatesData.UpsetRateDeviceOrbit(logical((SEURatesData.Shielding==ii).*idx_Config));
        %Combined_Upsets=Block_Upsets+Config_Upsets;
        Const = polyfit(unique(SEURatesData.StormLevel)',log10(Config_Upsets'),1);%fit the log-log space curve,(storm level is already in log space)
        m = Const(1); k = Const(2);%save our fit parameters so we can interpolate with them later
        fit_params=vertcat(fit_params,[m k ii]);
        %extrapolated_SEUs = 10.^(m.*log10([1:150000])+(k)); %not neccessary but this is how we would check if the extrapolation was a good fit
end

sc_shielding_m_SEU=interp1(fit_params(:,3),fit_params(:,1),sc_shielding); %and we can use these to interpolate fit parameters for a user-specified shielding level
sc_shielding_k_SEU=interp1(fit_params(:,3),fit_params(:,2),sc_shielding); %so when we stochastically generate a storm's PFU, we can translate that to the expected SEUs the spacecraft would receive with it's given shielding level, orbit, and device type
%% Seed Generations

theta_t=(theta_null/4000)+((K/4000)*betapdf(t,p,q));

expected_events=zeros(1,length(full_period)); %The Kim et al. Model with Uncertainty Included
for i=31:30:3991
    expected_events((i-1)/30)=sum([theta_t(i-30:i)]); %these are our mean events per month, in the next loop we convert add uncertainty 
end

expected_events_kim_monte=zeros(TotalSeeds,length(full_period));
event_intensities_monte=cell(TotalSeeds,length(full_period));
SPE_Dose_monte=zeros(TotalSeeds,length(full_period));
total_radiation_monte=zeros(TotalSeeds,length(full_period));
SEU_Probabilities_monte=cell(TotalSeeds,length(full_period));
S5_Flags=zeros(1,length(full_period));

for ii=1:TotalSeeds
    S5_Flags(ii)=0; %So we can find cycles where an S5 was rolled later on
    expected_events_kim=zeros(1,length(full_period));
    event_intensities=cell(1,length(full_period));
    SPE_Dose=zeros(1,length(full_period));
    total_radiation=zeros(1,length(full_period));
    SEUs_Probabilities=cell(1,length(full_period));
    for i=1:length(full_period) %for every month of every seed, we generate a number of expected events based on Kim et al.
        expected_events_kim(i)=floor(norminv(rand(),expected_events(i)/2,1.07-(abs(i-(length(full_period)/2))/(2*length(full_period))))); %SS24 Params
        if expected_events_kim(i)<=0
            expected_events_kim(i)=0;
            event_intensities{i}=0;
        else
            event_intensities{i}=random(SPE_Intensity_Dist,1,expected_events_kim(i));%then for every event, we also generate an SPE with an intensity based on our CDF
            SPE_Dose(i)=sum(10.^(sc_shielding_m_dose.* event_intensities{i}+(sc_shielding_k_dose)));
            total_radiation(i)=SPE_Dose(i);
            for qq=1:length(event_intensities{i})
                SEU_Rate=10.^(sc_shielding_m_SEU.*(event_intensities{i}(qq))+(sc_shielding_k_SEU));
                SEUs_Probabilities{i}(qq)=(exp(-1*SEU_Rate))^5;
            end
            if sum(event_intensities{i}>=5)==1
                S5_Flags(ii)=1; %So we can find cycles where an S5 was rolled later on
            end
        end
        total_radiation(i)=total_radiation(i)+BackgroundSolarCycleDoses(sc_shielding-4,i);
    end
    expected_events_kim_monte(ii,1:end)=expected_events_kim;
    event_intensities_monte(ii,1:end)=event_intensities;
    SPE_Dose_monte(ii,1:end)=SPE_Dose;
    total_radiation_monte(ii,1:end)=total_radiation;
    SEU_Probabilities_monte(ii,1:end)=SEUs_Probabilities;
end %At the end of this we have a random number of events for every month in the time step
SEU_Probs=SEU_Probabilities_monte;
Rad_Accum=total_radiation_monte;
end
% sort(sum(SEU_Probabilities_monte,2))
% toc
% fprintf("Average TID: %.2f kRad\nMaximum TID: %.2f kRad",mean(sum(total_radiation_monte,2)),max(sum(total_radiation_monte,2)));
% cdfplot(sum(total_radiation_monte,2))
% hold on
% end
% xline(30,'--r','label','Careful COTS','LabelVerticalAlignment','middle','FontSize',26,'FontName','Times','FontWeight','bold')
% xline(100,'--r','label','Space-Tolerant COTS','LabelVerticalAlignment','middle','FontSize',26,'FontName','Times','FontWeight','bold')
% patch([5 25 25 5], [0 0 1 1],'yellow','FaceAlpha', 0.1,'EdgeColor','none')
% legend({"10"; "20"; "30"; "80"; "100";"Careful COTS";"Space-Tolerant";"Standard COTS"})
% xlim([0 130])
% set(gcf,'DefaultAxesFontName','Times New Roman','DefaultAxesFontWeight','bold');
% set(gcf,'DefaultTextFontName','Times New Roman','DefaultAxesFontWeight','bold');
% set(gcf,'DefaultTextColor','black')
% set(gca, 'FontSize',26,'FontName','Times','YColor','black','FontWeight','bold');
% xlabel('TID (kRad)','FontName','Times','FontWeight','bold');
% ylabel('Cumulative Probability','FontName','Times','FontWeight','bold');
% set(gca, 'FontSize',26,'FontName','Times','YColor','black','FontWeight','bold');
% set(gca, 'FontSize',26,'FontName','Times','XColor','black','FontWeight','bold');
% grid on
% sort(sum(total_radiation_monte,2))
% figure()
% fprintf("Average TID: %.2f kRad\nMaximum TID: %.2f kRad",mean(sum(total_radiation_monte,2)),max(sum(total_radiation_monte,2)));
% cdfplot(sum(total_radiation_monte,2))







% %% Seed Generation
% for Seed=1:TotalSeeds
%     S5_Present=0;
%     num_storms=zeros(1,length(full_period));
%     storm_intensity=zeros(10,length(full_period));
%     storm_length=zeros(10,length(full_period));
%     unshielded_radiation=zeros(1,length(full_period));
%     S4_Times=[];
%     S5_Times=[];
%     for i=1:length(full_period) %Generate a Random Number of Storms for Each Month
%         num_storms(i)=floor(norminv(rand(),1-(7*abs(i-67)/133),1.7-((abs(i-67)/(2*length(full_period))))));
%         if(num_storms(i)<0)
%             num_storms(i)=0;
%         end
%         monthly_storms(Seed,1:end)=num_storms;
%         total_storms(Seed)=sum(num_storms);
%         for ii=1:1:num_storms(i)
%             seed=rand()*(1-(abs(i-66)/66));
%             if seed<=0.24
%                 storm_intensity(ii,i)=rand()*100;
%             elseif seed<=0.51
%                 storm_intensity(ii,i)=rand()*1000;
%             elseif seed<=0.75
%                 storm_intensity(ii,i)=rand()*10000;
%             elseif seed<=0.89
%                 storm_intensity(ii,i)=rand()*100000;
%                 S4_Times=horzcat(S4_Times,i);
%             elseif seed<=0.898
%                 storm_intensity(ii,i)=.5*rand()*1000000;
%                 S5_Times=horzcat(S5_Times,i);
%                 S5_Present=1;
%             end
%             storm_length(ii,i)=logninv(.82*rand(),2.4506,1.4658); %Generate Storm Lengths for Each Storm (Hours)
%         end
%     end
%     unshielded_radiation_all(Seed,:)=sum([.0207*storm_intensity.*storm_length]); %based on linear fit of storm intensity to radiation received in SHIELDOSE
%     cum_radiation_all(Seed,:)=cumsum(unshielded_radiation_all(Seed,:),2);
%     S4_Times_All=vertcat(S4_Times_All,{S4_Times});
%     S5_Times_All=vertcat(S5_Times_All,{S5_Times});
%     S5_Cycles=S5_Cycles+S5_Present;
%     S5_Present=0;
% end
% toc
% 
% %% Assessment of Normal Distribution Monte Carlo Results
% 
% Num_Storms=0;
% for i=1:length(S4_Times_All)
% Num_Storms=Num_Storms+length(S4_Times_All{i});
% end
% S4_Num=Num_Storms/length(S4_Times_All)
% 
% Num_Storms=0;
% for i=1:length(S5_Times_All)
% Num_Storms=Num_Storms+length(S5_Times_All{i});
% end
% S5_Num=Num_Storms/length(S5_Times_All)